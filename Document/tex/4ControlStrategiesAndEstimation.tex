\chapter{Control Strategies and State Estimation} \label{ch:controlandestimation}
This project seeks to evaluate control strategies designed for a quadrotor, test its performance in simulation, and then implement them in the smartphone-based quadrotor prototype. In this chapter, the design procedure of the control and estimation algorithms for the quadrotor is shown. This algorithms are based on the linearized model of the quadrotor, detailed in Section \ref{sec:linearized}. Also, all the simulations carried out in MATLAB to verify the proper functioning of the designed algorithms are exposed.
\\\\
The state-space representation of the system, and the concept of controllability and observability, are briefly introduced in Section \ref{sec:generalities}. Then, Section \ref{sec:controlstrategies} shows the theoretical basis required for the design of the controllers used in this project. This controllers are the Linear Quadratic Integral (LQI) controller and the $H_\infty$ controller.
\\\\
Section \ref{sec:controldesign} presents the considerations made for the design of the two types of controllers according to the flight mode of the quadrotor. In addition, this section shows the simulated response of the quadrotor being controlled by both types of controllers in each flight mode.
\\\\
Finally, the state estimation algorithm developed mainly for the case of the LQI controller, is detailed in Section \ref{sec:stateestimation}.

\section{Concept and Generalities}
\label{sec:generalities}

\subsection{State Space Representation}
Recalling from Section \ref{sec:linearized}, the dynamic model of the quadrotor, based on its six $DoF$, is represented by the linear state-space model
\begin{align}
\label{ec:statespace}
\begin{split}
\dot{\mathbf{x}}(t) & = A\mathbf{x}(t)+B\mathbf{u}(t),\\[10px]
\mathbf{y}(t) & = C\mathbf{x}(t)+D\mathbf{u}(t),
\end{split}
\end{align}
where $A$ is the system matrix; $B$ is the input matrix; $C$ is the output matrix; $D$ is the feed-through matrix; $\mathbf{x}$ is the states vector of size $\mathit{n_x}$; $\mathbf{u}$ is the inputs vector of size $\mathit{n_u}$; and $\mathbf{y}$ is the outputs vector of size $\mathit{n_y}$.
\\\\
For simplicity, the state-space model representation shown in (\ref{ec:statespace}), can be represented by the quartet of matrices $\mathcal{G}$ as
\begin{equation}\label{eqn:ss}
\mathcal{G} = \mleft[
\begin{array}{c|c}
  A & B \\
  \hline
  C & D
\end{array}
\mright].
\end{equation}
For the design of each controller, only the dynamics that are required to control, according to the flight mode in which the quadrotor is set, are taken into account. Therefore, system $\mathcal{G}$ will vary for each flight mode.

\subsection{Controllability and Observability}
The concept of controllability is related to the question of whether or not there exists a sequence of $\mathbf{u}$ capable of changing the states $\mathbf{x}$ from an initial value $\mathbf{x_0}$, to a desired final value $\mathbf{x_f}$, in a finite time. On the other hand, observability refers to the possibility of inferring, in finite time, the initial value of the states $\mathbf{x_0}$ knowing just the system dynamics $\mathcal{G}$ and its outputs $\mathbf{y}$ \cite{controlability1981}.
\\\\
Typically, the controllability and observability of a system are determined using the so-called controllability and observability matrices, $\mathcal{C_{G}}$ and $\mathcal{O_{G}}$ respectively.
This matrices depend on the system matrices $A$, $B$ and $C$, and are set as
\begin{align}
\begin{split}
\mathcal{C_{G}} & =
\begin{bmatrix}
B &  AB & \hdots & A^{k-1}B
\end{bmatrix},\\[5px]
\mathcal{O_G} & = \begin{bmatrix}
C\\
CA\\
\vdots\\
CA^{k-1}
\end{bmatrix}.
\end{split}
\end{align}
Thus, the system $\mathcal{G}$ is defined as controllable if $\mathcal{C_G}$ have $\mathit{n_x}$ linear independent rows (or columns). This is, the rank of $\mathcal{C_G}$ is equal to $\mathit{n_x}$. Analogous to the controllability, the observability of $\mathcal{G}$ is checked if the rank of the matrix $\mathcal{O_G}$ is equal to $\mathit{n_x}$.
\\\\
Another way to check the controllability and observability features of $\mathcal{G}$ is using the controllability and observability Grammians $\mathcal{W}_{c}$ and $\mathcal{W}_{o}$ defined as the solutions to the Lyapunov equations
\begin{align}
\begin{split}
0 & = A\mathcal{W}_{c} + \mathcal{W}_{c}A^{T} + BB^{T},\\[5px]
0 & = A^{T}\mathcal{W}_{o} + \mathcal{W}_{o}A + C^{T}C,
\end{split}
\end{align}
where
\begin{align}
\begin{split}
\mathcal{W}_{c} & = \int_{0}^{\infty}e^{At}BB^{T}e^{A^{T}t}dt,\\[5px]
\mathcal{W}_{o} & = \int_{0}^{\infty}e^{A^{T}t}C^{T}Ce^{At}dt.
\end{split}
\end{align}
In this case, if the matrices $\mathcal{W}_{c}$ and $\mathcal{W}_{o}$ are positive definite, the system is both controllable and observable \cite{Werner2012}.

\section{Control Strategies}
\label{sec:controlstrategies}
This section exposes the controllers design procedure. Here, the mathematical procedure to design a linear quadratic integral controller is described. It includes a regulator and an estimator, in addition to a gain compensator, allowing the system to track a trajectory. The design process of a $H_{\infty}$ controller is shown, taking into account some weighting sensitivities.

\subsection{Linear Quadratic Integral (LQI) Controller}
\subsubsection{Optimal Problem Solution}
The design of optimal controllers seeks that a dynamic system can be controlled achieving a minimum cost. The cost function is determined by the control designer \cite{Steinbuch2007}. Designing an finite-time regulator, a linear quadratic regulator (LQR) is set while looking for the minimization of the cost function $\mathcal{V}$ as
\begin{equation}
\mathcal{V} = \int_{0}^{T}\mathcal{L}(\mathbf{x},\mathbf{u},t)\ dt + \Psi(\mathbf{x},\mathbf{u},t),
\end{equation}
where
\begin{align}
\begin{split}
\mathcal{L}(\mathbf{x},\mathbf{u},t) = \mathbf{x}^{T}\mathcal{Q}\mathbf{x} + \mathbf{u}^{T}\mathcal{R}\mathbf{u},\\[5px]
\Psi(\mathbf{x},\mathbf{u},t) = \mathbf{x}^{T}(T)\mathcal{S}\mathbf{x}(T),
\end{split}
\end{align}
$\mathcal{R}$ is a positive definite matrix; and $\mathcal{Q}$ and $\mathcal{S}$ are positive semi-definite matrices. These matrices penalize the inputs, states and the terminal cost, respectively. Thus, the optimal controller design problem turns into an optimization problem where it is necessary to find an input $\mathbf{u}^{*}$ such that minimizes $\mathcal{V}$ for a controllable system subject to
\begin{align}
\begin{split}
\dot{\mathbf{x}}(t) & = \mathbf{f}(\mathbf{x}, \mathbf{u}, t) \approx A\mathbf{x}(t)+B\mathbf{u}(t),\\[5px]
\mathbf{x}(0) & = \mathbf{x_0},\ \ \ t \in [0, T].
\end{split}
\end{align}
This minimization is achieved using the Pontryagin's maximum principle \cite{Murray2009}, where
\begin{equation}
\mathcal{H}(\mathbf{x},\mathbf{u},\lambda_\mathcal{P},t) = \mathcal{L}(\mathbf{x},\mathbf{u},t) + \lambda_\mathcal{P}^{T}\mathbf{f}(\mathbf{x}, \mathbf{u}, t)
\end{equation}
is the Hamiltonian function, with $\lambda_\mathcal{P}$ being the vector of co-state variables of size $\mathit{n_x}$, and
\begin{align}
\label{eqn:hamilt}
\begin{split}
\dot{\mathbf{x}}(t) & = \left(\dfrac{\partial \mathcal{H}(\mathbf{x},\mathbf{u},\lambda_\mathcal{P},t)}{\partial \lambda_\mathcal{P}}\right)^{T} = A\mathbf{x}(t)+B\mathbf{u}(t),\\[5px]
-\dot{\lambda}_{\mathcal{P}}(t) & = \left(\dfrac{\partial \mathcal{H}(\mathbf{x},\mathbf{u},\lambda_\mathcal{P},t)}{\partial \mathbf{x}}\right)^{T} = \mathcal{Q}\mathbf{x}(t) + A^{T}\lambda_{\mathcal{P}}(t),\\[5px]
0 & = \dfrac{\partial \mathcal{H}(\mathbf{x},\mathbf{u},\lambda_\mathcal{P},t)}{\partial \mathbf{u}} = \mathcal{R}\mathbf{u}(t) + \lambda_\mathcal{P}^{T}(t)B.
\end{split}
\end{align}
Thereby, from (\ref{eqn:hamilt}), the optimal solution to $\mathbf{u}$ that minimizes $\mathcal{H}(\mathbf{x},\mathbf{u},\lambda_\mathcal{P},t)$, and by Pontryagin's maximum principle, the cost function $\mathcal{V}$, is
\begin{equation}
\mathbf{u}^{*}(t) = -\mathcal{R}^{-1}B^{T}\lambda_\mathcal{P}(t).
\end{equation}
Assuming that $\lambda_\mathcal{P}(t) = \mathcal{P}(t)\mathbf{x}(t)$, the optimal input $\mathbf{u}^{*}$ depends directly on a feedback vector, which is the state vector $\mathbf{x}$, such that
\begin{align}
\label{eqn:optimalu}
\begin{split}
\mathbf{u}^{*}(t) & = \mathbf{K_{lqr}}(t)\mathbf{x}(t),\\[5px]
\mathbf{K_{lqr}}(t) & = -\mathcal{R}^{-1}B^{T}\mathcal{P}(t).
\end{split}
\end{align}
Here, matrix $\mathcal{P}(t)$ is a solution of the Riccati Equation \cite{Moore1989}
	\begin{equation}
	-\dot{\mathcal{P}} = \mathcal{P}A + A^{T}\mathcal{P} + \mathcal{Q} - \mathcal{P}B\mathcal{R}^{-1}B^{T}\mathcal{P}.
	\end{equation}
When $T \to \infty$, an infinite-time regulator is designed. Here, aiming for a steady-state solution, the terminal cost $\Psi(\mathbf{x}, \mathbf{u},t)$ is eliminated, and the matrix $\mathcal{P}$ is assumed to be constant. Thus, $\mathcal{P}$ is a solution of the Algebraic Riccati Equation (ARE)
	\begin{equation}
	0 = \mathcal{P}A + A^{T}\mathcal{P} + \mathcal{Q} - \mathcal{P}B\mathcal{R}^{-1}B^{T}\mathcal{P}.
	\end{equation}
Consequently, in the infinite-time LQR, the optimal input $\mathbf{u}^{*}$ is achieved by multiplying the state vector $\mathbf{x}$ with the constant feedback gain matrix
\begin{equation}
\mathbf{K_{lqr}} = -\mathcal{R}^{-1}B^{T}\mathcal{P}.
\end{equation}
\\As the feedback gain is not a dynamical system, but a static matrix, the order of the closed-loop dynamics is the same as the one of the system dynamics $\mathcal{G}$. The closed-loop dynamics are written as
\begin{equation}
\dot{\mathbf{x}} = (A+B\mathbf{K_{lqr}})\mathbf{x}.
\end{equation}
When the desired state value $\mathbf{x_{des}}$ is different from zero, these reference value is applied to the dynamics through the feedback gain matrix as
\begin{equation}
\dot{\mathbf{x}} = (A+B\mathbf{K_{lqr}})\mathbf{x}-B\mathbf{K_{lqr}}\mathbf{x_{des}},
\end{equation}
due to the fact that the error $\mathbf{e} = \mathbf{x} - \mathbf{x_{des}}$ is used as the feedback vector of the LQR.

\subsubsection{Reference Tracking}
The LQR design is not made for reference tracking, but just for regulation. 
, to let the quadrotor track a defined trajectory, it is necessary to include a gain filter $v$ for the reference that compensates the total gain of the closed-loop system and enables the tracking of a reference input $r$. This gain filter is defined as
	\begin{equation}\label{eqn:v}
	v = -(C*(A+BF+F_{e}C)^{-1}*B)^{-1},
	\end{equation}
and its placing in the system is shown in Fig. \ref{fig:lqi}.
	\begin{figure}[h]
	\begin{center}
	\includegraphics[width=10.5cm]{lqi}
	\caption{Closed-loop system with gain compensation for the LQG controller aiming to track a reference.}
	\label{fig:lqi}
	\end{center}
	\end{figure}
\\where $G_{cl}$ is the closed-system with the LQG controller described in (\ref{eqn:ssgcl}).
\begin{equation}
\mathbf{x_i} = \int \mathbf{e}\ dt,\ \ \mathbf{x_i}(0) = \mathbf{0},
\end{equation}
\begin{equation}
\mathbf{x_{lqi}} = \begin{bmatrix}
\mathbf{x} \\
\mathbf{x_i}
\end{bmatrix},
\end{equation}
\begin{align}
\begin{split}
\begin{bmatrix}
\dot{\mathbf{x}}\\
\mathbf{\dot{x}_i}
\end{bmatrix} & = \begin{bmatrix}
A & \mathbf{0_{\mathit{n_y}\times \mathit{n_y}}} \\
-C & \mathbf{0_{\mathit{n_y}\times \mathit{n_y}}}
\end{bmatrix}\begin{bmatrix}
\mathbf{x} \\
\mathbf{x_i}
\end{bmatrix} + \begin{bmatrix}
B \\ \mathbf{0_{\mathit{n_y}\times \mathit{n_y}}}
\end{bmatrix}\mathbf{u} +  \begin{bmatrix}
\mathbf{0_{\mathit{n_x}\times \mathit{n_x}}} \\
\mathcal{I}_{\mathit{n_y}\times \mathit{n_y}}
\end{bmatrix}r \\[5px]
\mathbf{y} & = \begin{bmatrix}
C & \mathbf{0_{\mathit{n_y}\times \mathit{n_y}}}
\end{bmatrix}\begin{bmatrix}
\mathbf{x} \\
\mathbf{x_i}
\end{bmatrix}
\end{split}
\end{align}

\subsection{$H_\infty$ Controller}
\cite{Zhou1999}
For the design of the $H\infty$ controller, a generalized plant like the shown in the Fig. \ref{fig:augmentedPlant}, was built.
\begin{figure}[H]
	\begin{center}
	\includegraphics[width=6.5cm]{augmentedPlant.eps}
	\caption{Generalized plant with the weighting filters $W_s$ and $W_k$.}
	\label{fig:augmentedPlant}
	\end{center}
	\end{figure}	
In this generalized plant, $G$ represents the quadrotor dynamics, $K$ the controller, $r$ is the system reference, $e$ is the error, $u$ is the control input and $W_{s},\ W_{k}$ are weighting filters that must satisfy 
	\begin{equation}\label{eqn:hinf}
	\gamma = \left|\left|\begin{bmatrix}
	W_{s}S\\W_{k}KS
	\end{bmatrix}\right|\right|_{\infty} < 1,
	\end{equation}
\\where $S$ is the sensitivity function and $KS$ is the control sensitivity defined as
	\begin{equation}
	S = (\mathcal{I} + GK)^{-1},\ \ \ KS = K(\mathcal{I} + GK)^{-1}.
	\end{equation}
The weighting filters for the sensitivity and the control sensitivity were chosen as
\begin{align}\label{eqn:wswk}
\begin{split}
W_{S} &= \dfrac{w_{s}/M_{s}}{s + w_{s}}*\mathcal{I}_{4\times4}\ ,\\
W_{K} &= \dfrac{c}{M_{k}}\dfrac{s+w_{k}}{s+cw_{k}}*\mathcal{I}_{4\times4}\ ,
\end{split}
\end{align}
where $w_{s} = 10^{-4}$, $M_{s} = 10^{-4}$, $w_{k} = 20$, $M_{k} = 20$, and $c = 10^{3}$. With these weighting filters, the value of $\gamma$ is greater than one, and then it is necessary to rebuild the generalized plant using normalized weighting filters.
\\\\The $H_{\infty}$ controller can be simulated as shown in Fig. \ref{fig:hinfcontroller}.
	\begin{figure}[h]
	\begin{center}
	\includegraphics[width=7.0cm]{hinfcontroller.pdf}
	\caption{Closed-loop of the controlled system with an $H_{\infty}$ controller.}
	\label{fig:hinfcontroller}
	\end{center}
	\end{figure}
\subsubsection{$H_\infty$ Controller Order Reduction}
The designed $H_{\infty}$ controller for our quadrotor, will have 4 outputs (the quadrotor has 4 control inputs), 4 inputs (the quadrotor has 4 measured outputs) and 20 states (due to the 12 order plant, 4 order $W_{k}$ and 4 order $W_s$). To be able to implement this controller in a smartphone running Android, it it necessary to find a reduced order controller that behaves similarly to the full order controller $K$. To reduce the order of the controller, the singular values of the Hankel matrix
\begin{equation}
H_{k} = \begin{bmatrix}
C\\
CA\\
\vdots\\
CA^{k-1}
\end{bmatrix}
\begin{bmatrix}
B\\ AB \\ \vdots \\ A^{k-1}B
\end{bmatrix}^{T},
\end{equation}
are analysed. The energy of the Hankel singular values is shown in Fig. \ref{fig:hsv}.
\begin{figure}[h]
\begin{center}
\includegraphics[width=7.8cm]{HSV.pdf}  
\caption{Hankel singular values energy histogram of the designed controller.} 
\label{fig:hsv}
\end{center}
\end{figure}
\\\\As shown in Fig. \ref{fig:hsv}, the last ordered four states have unnoticeable energy when it is plotted; that means that these four states can be truncated from the controller without modifying its dynamics \cite{Skogestad2005}. 

\section{Controllers Design and Simulation}
\label{sec:controldesign}
fhfgfhfh
\subsection{Stabilize Mode}
fghgfh
\subsubsection{Dynamic Model}
\begin{align}
\begin{split}
\mathbf{x} = & \begin{bmatrix}
\psi & \dot{\psi} & \theta & \dot{\theta} & \phi & \dot{\phi}
\end{bmatrix}^{T},\\[15px]
\mathbf{y} = & \begin{bmatrix}
\psi & \theta & \phi
\end{bmatrix}^{T}
\end{split}
\end{align}
\begin{align}
\begin{split}
A = & 
\begin{bmatrix}
0 & 1 & 0 & 0 & 0 & 0 \\[2px]
0 & 0 & 0 & 0 & 0 & 0 \\[2px]
0 & 0 & 0 & 1 & 0 & 0 \\[2px]
0 & 0 & 0 & 0 & 0 & 0 \\[2px]
0 & 0 & 0 & 0 & 0 & 1 \\[2px]
0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix}, \\[15px]
B = & 
\begin{bmatrix}
0 & 0 & 0 & 0 & 0 & 0\\[5px]
0 & \dfrac{1}{J_{zz}} & 0 & 0 & 0 & 0\\[5px]
0 & 0 & 0 & \dfrac{1}{J_{yy}} & 0 & 0\\[5px]
0 & 0 & 0 & 0 & 0 & \dfrac{1}{J_{xx}}
\end{bmatrix}^{T}.
\end{split}
\end{align}
\begin{align}
\begin{split}
C = & 
\begin{bmatrix}
1 & 0 & 0 & 0 & 0 & 0 \\[2px]
0 & 0 & 1 & 0 & 0 & 0 \\[2px]
0 & 0 & 0 & 0 & 1 & 0
\end{bmatrix}, \\[15px]
D = &\ \mathbf{0_{3\times 4}}.
\end{split}
\end{align}
\subsubsection{Linear Quadratic Regulator}
rtrte

\begin{figure}[H]
\begin{subfigure}{.5\linewidth}
\centering
\includegraphics[width=7.0cm]{stabilize_psi_lqi}
\caption{Rotation about $x$ axis, $J_{xx}$ experiment}
\label{fig:stabilize_psi_lqi}
\end{subfigure}%
\begin{subfigure}{.5\linewidth}
\centering
\includegraphics[width=7.0cm]{stabilize_theta_lqi}
\caption{Rotation about $y$ axis, $J_{yy}$ experiment}
\label{fig:stabilize_theta_lqi}
\end{subfigure}\\[1ex]
\begin{subfigure}{\linewidth}
\centering
\includegraphics[width=7.0cm]{stabilize_phi_lqi}
\caption{Rotation about $z$ axis, $J_{zz}$ experiment}
\label{fig:stabilize_psi_lqi}
\end{subfigure}
\caption{Rotation about $x$, $y$ and $z$ axes during the bifilar pendulum experiments}
\label{fig:stabilize_lqi}
\end{figure}

\subsubsection{$H_\infty$ Controller}
rtrtererre
\begin{figure}[H]
\begin{subfigure}{.5\linewidth}
\centering
\includegraphics[width=7.0cm]{stabilize_psi_lqi}
\caption{Rotation about $x$ axis, $J_{xx}$ experiment}
\label{fig:stabilize_psi_lqi}
\end{subfigure}%
\begin{subfigure}{.5\linewidth}
\centering
\includegraphics[width=7.0cm]{stabilize_theta_lqi}
\caption{Rotation about $y$ axis, $J_{yy}$ experiment}
\label{fig:stabilize_theta_lqi}
\end{subfigure}\\[1ex]
\begin{subfigure}{\linewidth}
\centering
\includegraphics[width=7.0cm]{stabilize_phi_lqi}
\caption{Rotation about $z$ axis, $J_{zz}$ experiment}
\label{fig:stabilize_psi_lqi}
\end{subfigure}
\caption{Rotation about $x$, $y$ and $z$ axes during the bifilar pendulum experiments}
\label{fig:stabilize_lqi}
\end{figure}


\subsection{Altitude Hold Mode}
\subsubsection{Dynamic Model}

\begin{align}
\begin{split}
\mathbf{x} = & \begin{bmatrix}
z & \dot{z} & \psi & \dot{\psi} & \theta & \dot{\theta} & \phi & \dot{\phi}
\end{bmatrix}^{T},\\[15px]
\mathbf{y} = & \begin{bmatrix}
z & \psi & \theta & \phi
\end{bmatrix}^{T}
\end{split}
\end{align}
\begin{align}
\begin{split}
A = & 
\begin{bmatrix}
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\[2px]
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\[2px]
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix}, \\[15px]
B = & 
\begin{bmatrix}
0 & \dfrac{1}{m} & 0 & 0 & 0 & 0 & 0 & 0\\[5px]
0 & 0 & 0 & \dfrac{1}{J_{zz}} & 0 & 0 & 0 & 0\\[5px]
0 & 0 & 0 & 0 & 0 & \dfrac{1}{J_{yy}} & 0 & 0\\[5px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & \dfrac{1}{J_{xx}}
\end{bmatrix}^{T}.
\end{split}
\end{align}
\begin{align}
\begin{split}
C = & 
\begin{bmatrix}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\[2px]
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\[2px]
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 
\end{bmatrix}, \\[15px]
D = &\ \mathbf{0_{4\times 4}}.
\end{split}
\end{align}
\subsubsection{Linear Quadratic Regulator}
rtrterere
\begin{figure}[H]
\begin{subfigure}{.5\linewidth}
\centering
\includegraphics[width=7.0cm]{althold_z_lqi}
\caption{Rotation about $x$ axis, $J_{xx}$ experiment}
\label{fig:althold_z_lqi}
\end{subfigure}%
\begin{subfigure}{.5\linewidth}
\centering
\includegraphics[width=7.0cm]{althold_psi_lqi}
\caption{Rotation about $y$ axis, $J_{yy}$ experiment}
\label{fig:althold_psi_lqi}
\end{subfigure}\\[1ex]
\begin{subfigure}{0.5\linewidth}
\centering
\includegraphics[width=7.0cm]{althold_theta_lqi}
\caption{Rotation about $z$ axis, $J_{zz}$ experiment}
\label{fig:althold_theta_lqi}
\end{subfigure}
\begin{subfigure}{0.5\linewidth}
\centering
\includegraphics[width=7.0cm]{althold_phi_lqi}
\caption{Rotation about $z$ axis, $J_{zz}$ experiment}
\label{fig:althold_phi_lqi}
\end{subfigure}
\caption{Rotation about $x$, $y$ and $z$ axes during the bifilar pendulum experiments}
\label{fig:althold_lqi}
\end{figure}

\subsubsection{$H_\infty$ Controller}
rtrtererre

\begin{figure}[H]
\begin{subfigure}{.5\linewidth}
\centering
\includegraphics[width=7.0cm]{althold_z_lqi}
\caption{Rotation about $x$ axis, $J_{xx}$ experiment}
\label{fig:althold_z_lqi}
\end{subfigure}%
\begin{subfigure}{.5\linewidth}
\centering
\includegraphics[width=7.0cm]{althold_psi_lqi}
\caption{Rotation about $y$ axis, $J_{yy}$ experiment}
\label{fig:althold_psi_lqi}
\end{subfigure}\\[1ex]
\begin{subfigure}{0.5\linewidth}
\centering
\includegraphics[width=7.0cm]{althold_theta_lqi}
\caption{Rotation about $z$ axis, $J_{zz}$ experiment}
\label{fig:althold_theta_lqi}
\end{subfigure}
\begin{subfigure}{0.5\linewidth}
\centering
\includegraphics[width=7.0cm]{althold_phi_lqi}
\caption{Rotation about $z$ axis, $J_{zz}$ experiment}
\label{fig:althold_phi_lqi}
\end{subfigure}
\caption{Rotation about $x$, $y$ and $z$ axes during the bifilar pendulum experiments}
\label{fig:althold_lqi}
\end{figure}

\subsection{GNSS Dependent Flight Modes}

\subsubsection{Dynamic Model}
\begin{align}
\begin{split}
\mathbf{x} = & \begin{bmatrix}
x & \dot{x} & y & \dot{y} & z & \dot{z} & \psi & \dot{\psi} & \theta & \dot{\theta} & \phi & \dot{\phi}
\end{bmatrix}^{T},\\[15px]
\mathbf{y} = & \begin{bmatrix}
x & y & z & \psi & \theta & \phi
\end{bmatrix}^{T}
\end{split}
\end{align}

\begin{align}
\begin{split}
A = & 
\begin{bmatrix}
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & g & 0 & 0 & 0\\[2px]
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & g & 0\\[2px]
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix}, \\[15px]
B = & 
\begin{bmatrix}
0 & 0 & 0 & 0 & 0 & \dfrac{1}{m} & 0 & 0 & 0 & 0 & 0 & 0\\[5px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & \dfrac{1}{J_{zz}} & 0 & 0 & 0 & 0\\[5px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \dfrac{1}{J_{yy}} & 0 & 0\\[5px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \dfrac{1}{J_{xx}}
\end{bmatrix}^{T}.
\end{split}
\end{align}
\begin{align}
\begin{split}
C = & 
\begin{bmatrix}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\[2px]
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\[2px]
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\[2px]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0
\end{bmatrix}, \\[15px]
D = &\ \mathbf{0_{6\times 4}}.
\end{split}
\end{align}
\subsubsection{Linear Quadratic Regulator}
rtrterere
\begin{figure}[h]
	\begin{center}
	\includegraphics[width=0.8\textwidth]{auto_xyz_lqi}
	\caption{Closed-loop of the controlled system with an $H_{\infty}$ controller.}
	\label{fig:auto_xyz_lqi}
	\end{center}
	\end{figure}
	
\begin{figure}[H]
\begin{subfigure}{.5\linewidth}
\centering
\includegraphics[width=7.0cm]{auto_psi_lqi}
\caption{Rotation about $x$ axis, $J_{xx}$ experiment}
\label{fig:auto_psi_lqi}
\end{subfigure}%
\begin{subfigure}{.5\linewidth}
\centering
\includegraphics[width=7.0cm]{auto_theta_lqi}
\caption{Rotation about $y$ axis, $J_{yy}$ experiment}
\label{fig:auto_theta_lqi}
\end{subfigure}\\[1ex]
\begin{subfigure}{\linewidth}
\centering
\includegraphics[width=7.0cm]{auto_phi_lqi}
\caption{Rotation about $z$ axis, $J_{zz}$ experiment}
\label{fig:auto_psi_lqi}
\end{subfigure}
\caption{Rotation about $x$, $y$ and $z$ axes during the bifilar pendulum experiments}
\label{fig:auto_lqi}
\end{figure}

\subsubsection{$H_\infty$ Controller}
rtrtererre

\begin{figure}[h]
	\begin{center}
	\includegraphics[width=0.8\textwidth]{auto_xyz_lqi}
	\caption{Closed-loop of the controlled system with an $H_{\infty}$ controller.}
	\label{fig:auto_xyz_lqi}
	\end{center}
	\end{figure}
	
\begin{figure}[H]
\begin{subfigure}{.5\linewidth}
\centering
\includegraphics[width=7.0cm]{auto_psi_lqi}
\caption{Rotation about $x$ axis, $J_{xx}$ experiment}
\label{fig:auto_psi_lqi}
\end{subfigure}%
\begin{subfigure}{.5\linewidth}
\centering
\includegraphics[width=7.0cm]{auto_theta_lqi}
\caption{Rotation about $y$ axis, $J_{yy}$ experiment}
\label{fig:auto_theta_lqi}
\end{subfigure}\\[1ex]
\begin{subfigure}{\linewidth}
\centering
\includegraphics[width=7.0cm]{auto_phi_lqi}
\caption{Rotation about $z$ axis, $J_{zz}$ experiment}
\label{fig:auto_psi_lqi}
\end{subfigure}
\caption{Rotation about $x$, $y$ and $z$ axes during the bifilar pendulum experiments}
\label{fig:auto_lqi}
\end{figure}

\section{State Estimation Through Kalman Filter}
\label{sec:stateestimation}
The quadrotor dynamics are sensed exclusively using the on-board smartphone's sensors. Considering that these sensors have different sample frequencies, and poor accuracy, it is necessary to use estimation algorithms, as a Kalman filter, to get reliable state data with constant sample frequency.

\subsection{Attitude Estimation}
The Android API implements a Kalman filter for attitude estimation using the raw data deliverd by the smartphone's accelerometer, gyroscope and magnetometer, as exposed in \cite{Astudillo2017}. Using the quaternion $Q_s$ delivered by the Rotation virtual sensor included in the Android SDK, it is obtained an absolute orientation representation with respect to the Earth frame \cite{AndSensor}, with
\begin{align}\label{eqn:rotvector}
\begin{split}
Q_{s} &= \mathrm{e}^{(\alpha/2)(u\vv{i}+v\vv{j}+w\vv{k})} \\
&= \begin{bmatrix}
u\sin(\alpha / 2)\\
v\sin(\alpha / 2)\\
w\sin(\alpha / 2)\\
\cos(\alpha / 2)
\end{bmatrix} = \begin{bmatrix}
q_{0} \\
q_{1} \\
q_{2} \\
q_{3}
\end{bmatrix}
\end{split}
\end{align}
where $\alpha$ is the amount of degrees the quaternion is rotated around the axis $u\vv{i}+v\vv{j}+w\vv{k}$. The rotation matrix $R_{b}^{w}$ can be defined using $Q_s$ as
\begin{equation}
R_{b}^{w} = \begin{bmatrix}
1-2(q_{2}^{2}+q_{3}^{2}) & 2(q_{1}q_{2}-q_{0}q_{3}) & 2(q_{0}q_{2}+q_{1}q_{3}) \\
2(q_{1}q_{2}-q_{0}q_{3}) & 1-2(q_{1}^{2}+q_{3}^{2}) & 2(q_{2}q_{3}+q_{0}q_{1}) \\
2(q_{1}q_{3}+q_{0}q_{2}) & 2(q_{0}q_{1}+q_{2}q_{3}) & 1-2(q_{1}^{2}+q_{2}^{2})
\end{bmatrix}.
\end{equation}
Comparing the terms in the two representations of $R_{b}^{w}$, the Euler angles are obtained as
\begin{equation}\label{eqn:quattoeu}
\begin{bmatrix}
\psi \\
\theta \\
\phi
\end{bmatrix} =
\begin{bmatrix}
atan2(2(q_{3}q_{2} + q_{0}q{1}),1-2(q_{1}^{2} + q_{2}^{2})) \\
arcsin(2(q_{3}q_{1} - q_{2}q_{0})) \\
atan2(2(q_{3}q_{0} + q_{1}q{2}),1-2(q_{0}^{2} + q_{1}^{2})) 
\end{bmatrix}.
\end{equation}

\subsection{Position Estimation}
Taking into account that the global navigation satellite systems (GNSS) receivers in smartphones have an accuracy of around $3\ m$ and a sampling frequency of $1\ Hz$, a Kalman filter for position tracking is designed. In order to keep the estimation system independent from the application of controlling the quadrotor, this filter is based on the dynamics of a moving particle with constant acceleration between two samples
\begin{equation}
\xi(k+1) = \xi(k) + \dot{\xi}(k)t_{k} + 0.5\ddot{\xi}(k)t_{k}^{2},
\end{equation}
where $t_{k}$ is the sample time.\\\\
Using $E_{k} = \begin{bmatrix}
\xi & \dot{\xi} & \ddot{\xi}
\end{bmatrix}^{T}
 =
\begin{bmatrix}x_{k} & y_{k} & z_{k} & \dot{x}_{k} & \dot{y}_{k} & \dot{z}_{k} & \ddot{x}_{k} & \ddot{y}_{k} & \ddot{z}_{k} \end{bmatrix}^{T}$ as state vector and being 
\begin{equation}\label{eqn:A}
\Gamma = \begin{bmatrix}
   				 1 & 0 & 0 & t_{k} & 0 & 0 & 0.5t_{k}^{2} & 0 & 0\\
   				 0 & 1 & 0 & 0 & t_{k} & 0 & 0 & 0.5t_{k}^{2} & 0\\
   				 0 & 0 & 1 & 0 & 0 & t_{k} & 0 & 0 & t_{k}^{2}\\
   				 0 & 0 & 0 & 1 & 0 & 0 & t_{k} & 0 & 0\\
   				 0 & 0 & 0 & 0 & 1 & 0 & 0 & t_{k} & 0 \\
   				 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & t_{k} \\
   				 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
   				 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
   				 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 
				\end{bmatrix},
\end{equation}
the matrix that satisfies $E_{k+1} = \Gamma E_{k}$, the prediction of the state $\hat{E}_{k}^{-}$ and its covariance $P_{k}^{-}$ are obtained as
\begin{equation}\label{eqn:statePrognosis}
\hat{E}_{k}^{-} = \Gamma \hat{E}_{k-1},
\end{equation}
\begin{equation}\label{eqn:covariancePrognosis}
P_{k}^{-} = \Gamma P_{k-1} \Gamma^{T} + Q_{k},
\end{equation}
where $\hat{E}_{k-1}$ is the previous estimated state, $P_{k-1}$ the previous error covariance matrix and $Q_{k}$ the process variance. The state prediction is then corrected calculating the Kalman gain vector $K_k$ as
\begin{align}\label{eqn:correctionKalman}
\begin{split}
K_{k} &= P^{-}_{k}H^{T}(HP^{-}_{k}H^{T} + R)^{-1},
\end{split}
\end{align}
and updating the state estimation $\hat{E}_{k}$ and its covariance $P_{k}$, based on the measurements $\zeta_k$ as
\begin{align}\label{eqn:correctionKalman2}
\begin{split}
\hat{E}_{k} &= \hat{E}^{-}_{k} + K_{k}(\zeta_{k} - H\hat{E}^{-}_{k}),\\
P_{k} &= (\mathcal{I} - K_{k}H)P^{-}_{k},
\end{split}
\end{align}
where $R$ is the measurement covariance matrix, $\mathcal{I}$ is the identity matrix and $H$ is the matrix that relate $\zeta_k$ and $E_k$. $H$ is defined as
\begin{equation}\label{eqn:H}
H =\begin{bmatrix}
			1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
			0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
			0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
			0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
			0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
			0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1
			\end{bmatrix},
\end{equation}
considering that $\zeta_k \in R^{6}$ contains the GNSS measurements of $x_{m}$ and $y_{m}$, the barometer measurements of $z_{m}$ (in $m$), and the measurements of $\ddot{x}_{m}$, $\ddot{y}_{m}$ and $\ddot{z}_{m}$ in the Earth frame (in $m/s^{2}$).
\\\\
The $x_{m}$ and $y_{m}$ position measurements are acquired using the GNSS receiver in the smartphone. Each sample of these coordinates are initially set in an ellipsoidal representation of decimal degrees by the receiver, and then converted to a bi-dimensional representation in meter units using the cartographic projection Magna-Sirgas.
\\
The $z_{m}$ measurements are acquired using the barometric pressure sensor which delivers the pressure value $p_k$ in hPa. This signal is converted to meters as
\begin{equation}\label{eqn:hbarom}
z_{m} = 44330\left(1-\frac{p_k}{p_{0}}^{1/5.255}\right),
\end{equation}
where $p_{0}$ is the atmospheric pressure at sea level \cite{Lauszus2015}.\\\\
The remaining measurement signals are the accelerations with respect to the Earth frame, $\ddot{\xi}_{m}$. These signals are calculated using the raw acceleration measurements from the smartphone $a_{b}$, which are represented with respect to the smartphone's body frame, and the attitude quaternion $Q_s$ as
\begin{equation}
\ddot{\xi}_{m} = \begin{bmatrix}
\ddot{x}_{m} & \ddot{y}_{m} & \ddot{z}_{m}
\end{bmatrix}^{T} =Q_{s}a_{b}Q'_{s},
\end{equation}
where $Q'_{s}$ is the quaternion conjugate of $Q_{s}$.
\\\\
The vector $\zeta_k$ is then set as
\begin{equation}
\zeta_k = \begin{bmatrix}
x_{m} & y_{m} & z_{m} & \ddot{x}_{m} & \ddot{y}_{m} & \ddot{z}_{m}
\end{bmatrix}^{T}.
\end{equation}

\subsection{Particle Model}
rtrtrtrtrt

\subsection{Quadrotor Model}
ytytyttytt

\section{Conclusions}
This chapter presented the simulation and the testing of five control techniques
for the attitude control of a quadrotor. The first technique is based
on Lyapunov theory, it proved to be very reactive, especially for the yaw
angle control. However, the stabilization in the direct neighborhood of the
equilibrium point was not rigid enough to permit hover flight. The second
one is a PID controller, it proved to be well adapted to the quadrotor when
flying near hover. It was possible using this technique to successfully perform
the first autonomous flight. The PID controller was only able to control the
quadrotor in near hover and absence of large disturbances. The third one
is an LQ controller, it displayed average stabilization results. It showed to
be less dynamic than the PID. The fourth control technique is the Backstepping,
its ability to control the orientation angles in presence of relatively
high perturbations is very interesting. The sliding-mode technique is the fifth
approach, it did not provide excellent results. The switching nature of the
controller seems to be ill adapted to the dynamics of the quadrotor. The results
of all these control approaches conducted to a combination of PID and
Backstepping into the so-called Integral Backstepping. This was proposed
as a single tool to design attitude, altitude and position controllers. The
experiment has shown that OS4 is currently able to take-off, hover, land and
avoid collisions automatically. As far as we know, OS4 is the first quadrotor
practically capable of a collision avoidance maneuver.